## 	读取缓存区所有数据### 	缓存区最大为4096byte，直接读取4096byte即可	```conn,_ := net.Dial("tcp4","localhost:6379")var b = []byte("$2\r\n$3\r\nget\r\n$1a\r\n")_,_ = conn.Write(b)r := bufio.NewReader(conn)_,_=r.Read(make([]byte,4096))```### Read 函数解释> 这里值得注意的是，当要读取的字节大于buf最大值时会走io.read,所以不如直接使用io.readFull来读取全部数据```func (b *Reader) Read(p []byte) (n int, err error) {    n = len(p)    //读取0字节时，直接返回0    if n == 0 {        //判断可读字节        if b.Buffered() > 0 {            return 0, nil        }        //可读字节 <= 0 返回error        return 0, b.readErr()    }    // 如果缓存数据已被读取或者缓存buf中为空时    if b.r == b.w {        if b.err != nil {            return 0, b.readErr()        }        //如果想读的字节数大于、等于缓存大小时        if len(p) >= len(b.buf) {            //直接从io中读取想读的字节，因为读出来的数据大于缓存，则不需要往缓存中添加数据            n, b.err = b.rd.Read(p)            if n < 0 {                panic(errNegativeRead)            }            if n > 0 {                b.lastByte = int(p[n-1])                b.lastRuneSize = -1            }            return n, b.readErr()        }        //读取的数据小于等于缓存大小        b.r = 0        b.w = 0        //buf读满        n, b.err = b.rd.Read(b.buf)        if n < 0 {            panic(errNegativeRead)        }        if n == 0 {            return 0, b.readErr()        }        b.w += n	}	//copy函数copy 字节较小的数，len(p) < b.buf[b.r:b.w]  最多读取len(p)	n = copy(p, b.buf[b.r:b.w])	b.r += n	b.lastByte = int(b.buf[b.r-1])	b.lastRuneSize = -1	return n, nil}``````func (b *Reader) Buffered() int {	return b.w - b.r}```